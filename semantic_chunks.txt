[
  {
    "chunk": "Conte√∫do de: https://docs.flutter.dev/ui UI | Flutter docs.flutter.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic. Learn more . OK, got it list On this page chevron_right Building user interfaces with Flutter vertical_align_top Building user interfaces with Flutter Flutter is back at Google I/O! Watch live keynotes & sessions Flutter widgets are built using a modern framework that takes inspiration from React . The central idea is that you build your UI out of widgets. Widgets describe what their view should look like given their current configuration and state. When a widget's state changes, the widget rebuilds its description, which the framework diffs against the previous description in order to determine the minimal changes needed in the underlying render tree to transition from one state to the next. Hello world # The minimal Flutter app simply calls the runApp() function with a widget: import 'package:flutter/material.dart'; void main() { runApp( const Center( child: Text( 'Hello, world!', textDirection: TextDirection.ltr, style: TextStyle(color: Colors.blue), ), ), ); } The runApp() function takes the given Widget and makes it the root of the widget tree. In this example, the widget tree consists of\n\ntwo widgets, the Center widget and its child, the Text widget. The framework forces the root widget to cover the screen, which means the text \"Hello, world\" ends up centered on screen. The text direction needs to be specified in this instance; when the MaterialApp widget is used, this is taken care of for you, as demonstrated later. When writing an app, you'll commonly author new widgets that are subclasses of either StatelessWidget or StatefulWidget , depending on whether your widget manages any state. A widget's main job is to implement a build() function, which describes the widget in terms of other, lower-level widgets. The framework builds those widgets in turn until the process bottoms out in widgets that represent the underlying RenderObject , which computes and describes the geometry of the widget. Basic widgets # Flutter comes with a suite of powerful basic widgets, of which the following are commonly used: Text The Text widget lets you create a run of styled text within your application. Row , Column These flex widgets let you create flexible layouts in both the horizontal ( Row ) and vertical ( Column ) directions. The design of these objects is based on the web's flexbox layout model. Stack Instead of being linearly oriented (either horizontally or vertically), a Stack widget lets you place widgets on top of each other in paint order. You can then use the Positioned widget on children of a Stack to position them relative to the top, right, bottom, or left edge of the stack. Stacks are\n\nbased on the web's absolute positioning layout model. Container The Container widget lets you create a rectangular visual element."
  },
  {
    "chunk": "A container can be decorated with a BoxDecoration , such as a background, a border, or a shadow. A Container can also have margins, padding, and constraints applied to its size. In addition, a Container can be transformed in three-dimensional space using a matrix. Below are some simple widgets that combine these and other widgets: import 'package:flutter/material.dart'; class MyAppBar extends StatelessWidget { const MyAppBar({required this.title, super.key}); // Fields in a Widget subclass are always marked \"final\". final Widget title; @override Widget build(BuildContext context) { return Container( height: 56, // in logical pixels padding: const EdgeInsets.symmetric(horizontal: 8), decoration: BoxDecoration(color: Colors.blue[500]), // Row is a horizontal, linear layout. child: Row( children: [ const IconButton( icon: Icon(Icons.menu), tooltip: 'Navigation menu', onPressed: null, // null disables the button ), // Expanded expands its child // to fill the available space. Expanded(child: title), const IconButton( icon: Icon(Icons.search), tooltip: 'Search', onPressed: null, ), ], ), ); } }\n\nclass MyScaffold extends StatelessWidget { const MyScaffold({super.key}); @override Widget build(BuildContext context) { // Material is a conceptual piece // of paper on which the UI appears. return Material( // Column is a vertical, linear layout. child: Column( children: [ MyAppBar( title: Text( 'Example title', style: Theme.of(context) // .primaryTextTheme .titleLarge, ), ), const Expanded(child: Center(child: Text('Hello, world!'))), ], ), ); } } void main() { runApp( const MaterialApp( title: 'My app', // used by the OS task switcher home: SafeArea(child: MyScaffold()), ), ); } Be sure to have a uses-material-design: true entry in the flutter section of your pubspec.yaml file. It allows you to use the predefined set of Material icons . It's generally a good idea to include this line if you are using the Materials library. yaml name :\n\nmy_app flutter : uses-material-design : true Many Material Design widgets need to be inside of a MaterialApp to display properly, in order to inherit theme data. Therefore, run the application with a MaterialApp . The MyAppBar widget creates a Container with a height of 56 device-independent pixels with an internal padding of 8 pixels, both on the left and the right. Inside the container, MyAppBar uses a Row layout to organize its children. The middle child, the title widget, is marked as Expanded , which means it expands to fill any remaining available space that hasn't been consumed by the other children. You can have multiple Expanded children and determine the ratio in which they consume the available space using the flex argument to Expanded . The MyScaffold widget organizes its children in a vertical column. At the top of the column it places an instance of MyAppBar , passing the app bar a Text widget to use as its title."
  },
  {
    "chunk": "Passing widgets as arguments to other widgets is a powerful technique that lets you create generic widgets that can be reused in a wide variety of ways. Finally, MyScaffold uses an Expanded\n\nto fill the remaining space with its body, which consists of a centered message. For more information, check out Layouts . Using Material Components # Flutter provides a number of widgets that help you build apps that follow Material Design. A Material app starts with the MaterialApp widget, which builds a number of useful widgets at the root of your app, including a Navigator , which manages a stack of widgets identified by strings, also known as \"routes\". The Navigator lets you transition smoothly between screens of your application. Using the MaterialApp widget is entirely optional but a good practice. import 'package:flutter/material.dart'; void main() { runApp(const MaterialApp(title: 'Flutter Tutorial', home: TutorialHome())); } class TutorialHome extends StatelessWidget { const TutorialHome({super.key}); @override Widget build(BuildContext context) { // Scaffold is a layout for // the major Material Components. return Scaffold( appBar: AppBar( leading: const IconButton( icon: Icon(Icons.menu), tooltip: 'Navigation menu', onPressed: null, ), title: const Text('Example title'), actions: const [ IconButton( icon: Icon(Icons.search), tooltip: 'Search', onPressed: null, ), ], ), // body is the majority of the screen. body: const Center(child: Text('Hello, world!')), floatingActionButton: const FloatingActionButton(\n\ntooltip: 'Add', // used by assistive technologies onPressed: null, child: Icon(Icons.add), ), ); } } Now that the code has switched from MyAppBar and MyScaffold to the AppBar and Scaffold widgets, and from material.dart , the app is starting to look a bit more Material. For example, the app bar has a shadow and the title text inherits the correct styling automatically. A floating action button is also added. Notice that widgets are passed as arguments to other widgets. The Scaffold widget takes a number of different widgets as named arguments, each of which are placed in the Scaffold layout in the appropriate place. Similarly, the AppBar widget lets you pass in widgets for the leading widget, and the actions of the title widget. This pattern recurs throughout the framework and is something you might consider when designing your own widgets. For more information, check out Material Components widgets . Handling gestures # Most applications include some form of user interaction with the system. The first step in building an interactive application is to detect input gestures."
  },
  {
    "chunk": "See how that works by creating a simple button: import 'package:flutter/material.dart'; class MyButton extends StatelessWidget {\n\nconst MyButton({super.key}); @override Widget build(BuildContext context) { return GestureDetector( onTap: () { print('MyButton was tapped!'); }, child: Container( height: 50, padding: const EdgeInsets.all(8), margin: const EdgeInsets.symmetric(horizontal: 8), decoration: BoxDecoration( borderRadius: BorderRadius.circular(5), color: Colors.lightGreen[500], ), child: const Center(child: Text('Engage')), ), ); } } void main() { runApp( const MaterialApp( home: Scaffold(body: Center(child: MyButton())), ), ); } The GestureDetector widget doesn't have a visual representation but instead detects gestures made by the user. When the user taps the Container , the GestureDetector calls its onTap() callback, in this case printing a message to the console. You can use GestureDetector to detect a variety of input gestures, including taps, drags, and scales. Many widgets use a GestureDetector to provide optional callbacks for other widgets. For example, the IconButton , ElevatedButton\n\n, and FloatingActionButton widgets have onPressed() callbacks that are triggered when the user taps the widget. For more information, check out Gestures in Flutter . Changing widgets in response to input # So far, this page has used only stateless widgets. Stateless widgets receive arguments from their parent widget, which they store in final member variables. When a widget is asked to build() , it uses these stored values to derive new arguments for the widgets it creates. In order to build more complex experiences‚Äîfor example, to react in more interesting ways to user input‚Äîapplications typically carry some state. Flutter uses StatefulWidgets to capture this idea. StatefulWidgets are special widgets that know how to generate State objects, which are then used to hold state. Consider this basic example, using the ElevatedButton mentioned earlier: import 'package:flutter/material.dart'; class Counter extends StatefulWidget { // This class is the configuration for the state. // It holds the values (in this case nothing) provided // by the parent and used by the build method of the // State. Fields in a Widget subclass are always marked // \"final\". const Counter({super.key}); @override State<Counter> createState() => _CounterState(); } class _CounterState extends State<Counter> { int _counter = 0; void _increment() { setState(() { // This call to setState tells the Flutter framework // that something has changed in this State, which // causes it to rerun the build method below so that // the display can reflect the updated values. If you\n\n// change _counter without calling setState(), then // the build method won't be called again, and so // nothing would appear to happen. _counter++; }); } @override Widget build(BuildContext context) { // This method is rerun every time setState is called, // for instance, as done by the _increment method above."
  },
  {
    "chunk": "// The Flutter framework has been optimized to make // rerunning build methods fast, so that you can just // rebuild anything that needs updating rather than // having to individually changes instances of widgets. return Row( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ ElevatedButton(onPressed: _increment, child: const Text('Increment')), const SizedBox(width: 16), Text('Count: $_counter'), ], ); } } void main() { runApp( const MaterialApp( home: Scaffold(body: Center(child: Counter())), ), ); } You might wonder why StatefulWidget and State are separate objects. In Flutter, these two types of objects have different life cycles. Widgets are temporary objects, used to construct a presentation of the application in its current state. State objects, on the other hand, are persistent between calls to build() , allowing them to remember information. The example above accepts user input and directly uses the result in its build()\n\nmethod. In more complex applications, different parts of the widget hierarchy might be responsible for different concerns; for example, one widget might present a complex user interface with the goal of gathering specific information, such as a date or location, while another widget might use that information to change the overall presentation. In Flutter, change notifications flow \"up\" the widget hierarchy by way of callbacks, while current state flows \"down\" to the stateless widgets that do presentation. The common parent that redirects this flow is the State . The following slightly more complex example shows how this works in practice: import 'package:flutter/material.dart'; class CounterDisplay extends StatelessWidget { const CounterDisplay({required this.count, super.key}); final int count; @override Widget build(BuildContext context) { return Text('Count: $count'); } } class CounterIncrementor extends StatelessWidget { const CounterIncrementor({required this.onPressed, super.key}); final VoidCallback onPressed; @override Widget build(BuildContext context) { return ElevatedButton(onPressed: onPressed, child: const Text('Increment')); } } class Counter extends StatefulWidget { const Counter({super.key}); @override State<Counter> createState() => _CounterState(); } class _CounterState extends State<Counter> { int _counter = 0; void _increment() { setState(() { ++_counter; }); } @override Widget build(BuildContext context) { return Row( mainAxisAlignment: MainAxisAlignment.center, children: <Widget>[ CounterIncrementor(onPressed: _increment), const SizedBox(width: 16),\n\nCounterDisplay(count: _counter), ], ); } } void main() { runApp( const MaterialApp( home: Scaffold(body: Center(child: Counter())), ), ); } Notice the creation of two new stateless widgets, cleanly separating the concerns of displaying the counter ( CounterDisplay ) and changing the counter ( CounterIncrementor )."
  },
  {
    "chunk": "Although the net result is the same as the previous example, the separation of responsibility allows greater complexity to be encapsulated in the individual widgets, while maintaining simplicity in the parent. For more information, check out: StatefulWidget setState() Bringing it all together # What follows is a more complete example that brings together these concepts: A hypothetical shopping application displays various products offered for sale, and maintains a shopping cart for intended purchases. Start by defining the presentation class, ShoppingListItem : import 'package:flutter/material.dart'; class Product { const Product({required this.name}); final String name; } typedef CartChangedCallback = Function(Product product, bool inCart); class ShoppingListItem extends StatelessWidget { ShoppingListItem({ required this.product, required this.inCart, required this.onCartChanged,\n\n}) : super(key: ObjectKey(product)); final Product product; final bool inCart; final CartChangedCallback onCartChanged; Color _getColor(BuildContext context) { // The theme depends on the BuildContext because different // parts of the tree can have different themes. // The BuildContext indicates where the build is // taking place and therefore which theme to use. return inCart // ? Colors.black54 : Theme.of(context).primaryColor; } TextStyle? _getTextStyle(BuildContext context) { if (!inCart) return null; return const TextStyle( color: Colors.black54, decoration: TextDecoration.lineThrough, ); } @override Widget build(BuildContext context) { return ListTile( onTap: () { onCartChanged(product, inCart); }, leading: CircleAvatar( backgroundColor: _getColor(context), child: Text(product.name[0]), ), title: Text(product.name, style: _getTextStyle(context)), ); } } void main() { runApp( MaterialApp( home: Scaffold( body: Center( child: ShoppingListItem( product: const Product(name: 'Chips'), inCart: true, onCartChanged: (product, inCart) {}, ), ),\n\n), ), ); } The ShoppingListItem widget follows a common pattern for stateless widgets. It stores the values it receives in its constructor in final member variables, which it then uses during its build() function. For example, the inCart boolean toggles between two visual appearances: one that uses the primary color from the current theme, and another that uses gray. When the user taps the list item, the widget doesn't modify its inCart value directly. Instead, the widget calls the onCartChanged function it received from its parent widget. This pattern lets you store state higher in the widget hierarchy, which causes the state to persist for longer periods of time. In the extreme, the state stored on the widget passed to runApp() persists for the lifetime of the application. When the parent receives the onCartChanged callback, the parent updates its internal state, which triggers the parent to rebuild and create a new instance of ShoppingListItem with the new inCart value."
  },
  {
    "chunk": "Although the parent creates a new instance of ShoppingListItem when it rebuilds, that operation is cheap because the framework compares the newly built widgets with the previously built widgets and applies only the differences to the underlying RenderObject . Here's an example parent widget that stores mutable state: import 'package:flutter/material.dart'; class Product { const Product({required this.name}); final String name; } typedef CartChangedCallback = Function(Product product, bool inCart);\n\nclass ShoppingListItem extends StatelessWidget { ShoppingListItem({ required this.product, required this.inCart, required this.onCartChanged, }) : super(key: ObjectKey(product)); final Product product; final bool inCart; final CartChangedCallback onCartChanged; Color _getColor(BuildContext context) { // The theme depends on the BuildContext because different // parts of the tree can have different themes. // The BuildContext indicates where the build is // taking place and therefore which theme to use. return inCart // ? Colors.black54 : Theme.of(context).primaryColor; } TextStyle? _getTextStyle(BuildContext context) { if (!inCart) return null; return const TextStyle( color: Colors.black54, decoration: TextDecoration.lineThrough, ); } @override Widget build(BuildContext context) { return ListTile( onTap: () { onCartChanged(product, inCart); }, leading: CircleAvatar( backgroundColor: _getColor(context), child: Text(product.name[0]), ), title: Text(product.name, style: _getTextStyle(context)), ); } } class ShoppingList extends StatefulWidget { const ShoppingList({required this.products, super.key}); final List<Product> products; // The framework calls createState the first time // a widget appears at a given location in the tree. // If the parent rebuilds and uses the same type of\n\n// widget (with the same key), the framework re-uses // the State object instead of creating a new State object. @override State<ShoppingList> createState() => _ShoppingListState(); } class _ShoppingListState extends State<ShoppingList> { final _shoppingCart = <Product>{}; void _handleCartChanged(Product product, bool inCart) { setState(() { // When a user changes what's in the cart, you need // to change _shoppingCart inside a setState call to // trigger a rebuild. // The framework then calls build, below, // which updates the visual appearance of the app."
  },
  {
    "chunk": "if (!inCart) { _shoppingCart.add(product); } else { _shoppingCart.remove(product); } }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: const Text('Shopping List')), body: ListView( padding: const EdgeInsets.symmetric(vertical: 8), children: widget.products.map((product) { return ShoppingListItem( product: product, inCart: _shoppingCart.contains(product), onCartChanged: _handleCartChanged, ); }).toList(), ), ); } } void main() { runApp( const MaterialApp( title: 'Shopping App', home: ShoppingList( products: [ Product(name: 'Eggs'),\n\nProduct(name: 'Flour'), Product(name: 'Chocolate chips'), ], ), ), ); } The ShoppingList class extends StatefulWidget , which means this widget stores mutable state. When the ShoppingList widget is first inserted into the tree, the framework calls the createState() function to create a fresh instance of _ShoppingListState to associate with that location in the tree. (Notice that subclasses of State are typically named with leading underscores to indicate that they are private implementation details.) When this widget's parent rebuilds, the parent creates a new instance of ShoppingList , but the framework reuses the _ShoppingListState instance that is already in the tree rather than calling createState again. To access properties of the current ShoppingList , the _ShoppingListState can use its widget property. If the parent rebuilds and creates a new ShoppingList , the _ShoppingListState rebuilds with the new widget value. If you wish to be notified when the widget property changes, override the didUpdateWidget() function, which is passed an oldWidget to let you compare the old widget with the current widget.\n\nWhen handling the onCartChanged callback, the _ShoppingListState mutates its internal state by either adding or removing a product from _shoppingCart . To signal to the framework that it changed its internal state, it wraps those calls in a setState() call. Calling setState marks this widget as dirty and schedules it to be rebuilt the next time your app needs to update the screen. If you forget to call setState when modifying the internal state of a widget, the framework won't know your widget is dirty and might not call the widget's build() function, which means the user interface might not update to reflect the changed state. By managing state in this way, you don't need to write separate code for creating and updating child widgets. Instead, you simply implement the build function, which handles both situations. Responding to widget lifecycle events # After calling createState() on the StatefulWidget , the framework inserts the new state object into the tree and then calls initState() on the state object. A subclass of State can override initState to do work that needs to happen just once. For example, override initState to configure animations or to subscribe to platform services. Implementations of initState are required to start by calling super.initState ."
  },
  {
    "chunk": "When a state object is no longer needed, the framework calls dispose() on the state object. Override the dispose function to do cleanup work. For example, override\n\ndispose to cancel timers or to unsubscribe from platform services. Implementations of dispose typically end by calling super.dispose . For more information, check out State . Keys # Use keys to control which widgets the framework matches up with other widgets when a widget rebuilds. By default, the framework matches widgets in the current and previous build according to their runtimeType and the order in which they appear. With keys, the framework requires that the two widgets have the same key as well as the same runtimeType . Keys are most useful in widgets that build many instances of the same type of widget. For example, the ShoppingList widget, which builds just enough ShoppingListItem instances to fill its visible region: Without keys, the first entry in the current build would always sync with the first entry in the previous build, even if, semantically, the first entry in the list just scrolled off screen and is no longer visible in the viewport. By assigning each entry in the list a \"semantic\" key, the infinite list can be more efficient because the framework syncs entries with matching semantic keys and therefore similar (or identical) visual appearances. Moreover, syncing the entries semantically means that state retained in stateful child widgets remains attached to the same semantic entry rather than the entry in the same numerical position in the viewport. For more information, check out the Key API. Global keys # Use global keys to uniquely identify child widgets. Global keys must be globally unique across the entire widget hierarchy, unlike local keys which need only be unique among siblings. Because they are globally unique, a global key can be used to retrieve the state associated with a widget.\n\nFor more information, check out the GlobalKey API. Was this page's content helpful? thumb_up thumb_down Thank you for your feedback! feedback Provide details Thank you for your feedback! Please let us know what we can do to improve. bug_report Provide details Unless stated otherwise, the documentation on this site reflects the latest stable version of Flutter. Page last updated on 2025-05-19. View source or report an issue .\n\nConte√∫do de: https://docs.flutter.dev/ui/widgets Widgets | Flutter docs.flutter.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic. Learn more . OK, got it Flutter is back at Google I/O! Watch live keynotes & sessions Create beautiful apps faster with Flutter's collection of visual, structural, platform, and interactive widgets. In addition to browsing widgets by category, you can also see all the widgets in the widget index . Design systems # Flutter ships with two design systems as part of the SDK."
  },
  {
    "chunk": "Cupertino Beautiful and high-fidelity widgets that align with Apple's Human Interface Guidelines for iOS and macOS. Material components Visual, behavioral, and motion-rich widgets implementing the Material 3 design specification. You can find many more designs systems created by the Flutter community on pub.dev , the package repository for Dart and Flutter, like for example the Windows-inspired fluent_ui , macOS-inspired macos_ui , and the Ubuntu-inspired yaru widgets. Base widgets # Base widgets support a range of common rendering options like input, layout, and text. Accessibility Make your app accessible. Animation and motion Bring animations to your app. Assets, images, and icons Manage assets, display images, and show icons. Async Widgets supporting async patterns in your Flutter apps. Basics\n\nWidgets to know before building your first Flutter app. Input Take user input in addition to input widgets in Material components and Cupertino. Interaction models Respond to touch events and route users to different views. Layout Arrange other widgets columns, rows, grids, and many other layouts. Painting and effects These widgets apply visual effects to the children without changing their layout, size, or position. Scrolling Scroll multiple widgets as children of the parent. Styling Manage the theme of your app, make your app responsive to screen sizes, or add padding. Text Display and style text. Widget of the Week # 100+ short, 1-minute explainer videos to help you quickly get started with Flutter widgets. Watch on YouTube in a new tab: \"TextStyle - Flutter widget of the week\" Watch on YouTube in a new tab: \"flutter_rating_bar - Flutter package of the week\" Watch on YouTube in a new tab: \"LinearGradient - Flutter widget of the week\" Watch on YouTube in a new tab: \"AutoComplete - Flutter widget of the week\" Watch on YouTube in a new tab: \"NavigationRail - Flutter widget of the week\" Watch on YouTube in a new tab: \"mason - Flutter package of the week\" Watch more widget of the week videos Was this page's content helpful? thumb_up thumb_down Thank you for your feedback! feedback Provide details Thank you for your feedback! Please let us know what we can do to improve. bug_report Provide details Unless stated otherwise, the documentation on this site reflects the latest stable version of Flutter. Page last updated on 2025-03-12. View source or report an issue .\n\nConte√∫do de: https://docs.flutter.dev/ui/layout Layout | Flutter docs.flutter.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic. Learn more . OK, got it list On this page chevron_right Layouts in Flutter vertical_align_top Layouts in Flutter Flutter is back at Google I/O! Watch live keynotes & sessions Overview # The core of Flutter's layout mechanism is widgets. In Flutter, almost everything is a widget‚Äîeven layout models are widgets. The images, icons, and text that you see in a Flutter app are all widgets."
  },
  {
    "chunk": "But things you don't see are also widgets, such as the rows, columns, and grids that arrange, constrain, and align the visible widgets. You create a layout by composing widgets to build more complex widgets. Conceptual example # In the following example, the first screenshot displays three icons with labels and the second screenshot includes the visual layout for rows and columns. In the second screenshot, debugPaintSizeEnabled is set to true so you can see the visual layout. Here's a diagram of the widget tree for the previous example: Most of this should look as you might expect, but you might be wondering about the containers (shown in pink). Container is a widget class that allows you to customize its child widget. Use a Container when you want to add padding, margins, borders, or background color, to name some of its capabilities. Each Text widget is placed in a Container to add margins. The entire\n\nRow is also placed in a Container to add padding around the row. The rest of the UI is controlled by properties. Set an Icon 's color using its color property. Use the Text.style property to set the font, its color, weight, and so on. Columns and rows have properties that allow you to specify how their children are aligned vertically or horizontally, and how much space the children should occupy. Lay out a widget # How do you lay out a single widget in Flutter? This section shows you how to create and display a simple widget. It also shows the entire code for a simple Hello World app. In Flutter, it takes only a few steps to put text, an icon, or an image on the screen. 1. Select a layout widget # Choose from a variety of layout widgets based on how you want to align or constrain a visible widget, as these characteristics are typically passed on to the contained widget. For example, you could use the Center layout widget to center a visible widget horizontally and vertically: dart Center ( // Content to be centered here. ) 2. Create a visible widget # Choose a visible widget for your app to contain visible elements, such as text , images , or icons . For example, you could use the Text\n\nwidget display some text: dart Text ( 'Hello World' ) 3. Add the visible widget to the layout widget # All layout widgets have either of the following: A child property if they take a single child‚Äîfor example, Center or Container A children property if they take a list of widgets‚Äîfor example, Row , Column , ListView , or Stack . Add the Text widget to the Center widget: dart const Center ( child : Text ( 'Hello World' ), ), 4. Add the layout widget to the page # A Flutter app is itself a widget, and most widgets have a\n\nbuild() method. Instantiating and returning a widget in the app's build() method displays the widget."
  },
  {
    "chunk": "Standard apps Material apps Cupertino apps For a general app, you can add the Container widget to the app's build() method: dart class MyApp extends StatelessWidget { const MyApp ({ super .key}); @override Widget build ( BuildContext context) { return Container ( decoration : const BoxDecoration (color : Colors .white), child : const Center (\n\nchild : Text ( 'Hello World' , textDirection : TextDirection .ltr, style : TextStyle (fontSize : 32 , color : Colors .black87), ), ), ); } } By default, a general app doesn't include an AppBar , title, or background color. If you want these features in a general app, you have to build them yourself. This app changes the background color to white and the text to dark grey to mimic a Material app. For a Material app, you can use a Scaffold widget; it provides a default banner, background color, and has API for adding drawers, snack bars, and bottom sheets. Then you can add the Center widget directly to the body property for the home page. dart class MyApp extends StatelessWidget\n\n{ const MyApp ({ super .key}); @override Widget build ( BuildContext context) { const String appTitle = 'Flutter layout demo' ; return MaterialApp ( title : appTitle, home : Scaffold ( appBar : AppBar (title : const Text (appTitle)), body : const Center ( child : Text (\n\n'Hello World' ), ), ), ); } } To create a Cupertino app, use the CupertinoApp and CupertinoPageScaffold widgets. Unlike Material , it doesn't provide a default banner or background color. You need to set these yourself. To set default colors, pass in a configured CupertinoThemeData to your app's theme property. To add an iOS-styled navigation bar to the top of your app, add a CupertinoNavigationBar widget to the navigationBar property of your scaffold. You can use the colors that CupertinoColors provides to configure your widgets to match iOS design. To lay out the body of your app, set the child property of your scaffold with the desired widget as its value, like Center or Column . To learn what other UI components you can add, check out the Cupertino library . dart class MyApp extends StatelessWidget\n\n{ const MyApp ({ super .key}); @override Widget build ( BuildContext context) { return const CupertinoApp ( title : 'Flutter layout demo' , theme : CupertinoThemeData ( brightness : Brightness .light, primaryColor : CupertinoColors .systemBlue, ), home : CupertinoPageScaffold ( navigationBar : CupertinoNavigationBar ( backgroundColor : CupertinoColors .systemGrey,\n\nmiddle : Text ( 'Flutter layout demo' ), ), child : Center ( child : Column ( mainAxisAlignment : MainAxisAlignment .center, children : [ Text ( 'Hello World' )], ), ), ), ); } } 5. Run your app # After you've added your widgets, run your app. When you run the app, you should see Hello World . App source code: Material app Non-Material app Lay out multiple widgets vertically and horizontally # One of the most common layout patterns is to arrange widgets vertically or horizontally."
  },
  {
    "chunk": "You can use a Row\n\nwidget to arrange widgets horizontally, and a Column widget to arrange widgets vertically. To create a row or column in Flutter, you add a list of children widgets to a Row or Column widget. In turn, each child can itself be a row or column, and so on. The following example shows how it is possible to nest rows or columns inside of rows or columns. This layout is organized as a Row . The row contains two children: a column on the left, and an image on the right: The left column's widget tree nests rows and columns. You'll implement some of Pavlova's layout code in Nesting rows and columns . Aligning widgets # You control how a row or column aligns its children using the mainAxisAlignment and crossAxisAlignment properties. For a row, the main axis runs horizontally and the cross axis runs vertically. For a column, the main axis runs vertically and the cross axis runs horizontally. The MainAxisAlignment and CrossAxisAlignment enums offer a variety of constants for controlling alignment. In the following example, each of the 3 images is 100 pixels wide. The render box (in this case, the entire screen) is more than 300 pixels wide, so setting the main axis alignment to spaceEvenly divides the free horizontal space evenly between, before, and after each image. dart Row ( mainAxisAlignment : MainAxisAlignment .spaceEvenly, children : [ Image\n\n. asset ( 'images/pic1.jpg' ), Image . asset ( 'images/pic2.jpg' ), Image . asset ( 'images/pic3.jpg' ), ], ); App source: row_column Columns work the same way as rows. The following example shows a column of 3 images, each is 100 pixels high. The height of the render box (in this case, the entire screen) is more than 300 pixels, so setting the main axis alignment to spaceEvenly divides the free vertical space evenly between, above, and below each image. dart Column ( mainAxisAlignment : MainAxisAlignment .spaceEvenly, children : [ Image . asset ( 'images/pic1.jpg' ), Image . asset\n\n( 'images/pic2.jpg' ), Image . asset ( 'images/pic3.jpg' ), ], ); App source: row_column Sizing widgets # When a layout is too large to fit a device, a yellow and black striped pattern appears along the affected edge. Here is an example of a row that is too wide: Widgets can be sized to fit within a row or column by using the Expanded widget. To fix the previous example where the row of images is too wide for its render box, wrap each image with an Expanded widget. dart Row ( crossAxisAlignment : CrossAxisAlignment .center, children : [ Expanded (child : Image . asset ( 'images/pic1.jpg' )), Expanded\n\n(child : Image . asset ( 'images/pic2.jpg' )), Expanded (child : Image . asset ( 'images/pic3.jpg' )), ], ); App source: sizing Perhaps you want a widget to occupy twice as much space as its siblings. For this, use the Expanded widget flex property, an integer that determines the flex factor for a widget. The default flex factor is 1."
  },
  {
    "chunk": "The following code sets the flex factor of the middle image to 2: dart Row ( crossAxisAlignment : CrossAxisAlignment .center, children : [ Expanded (child : Image . asset (\n\n'images/pic1.jpg' )), Expanded ( flex : 2 , child : Image . asset ( 'images/pic2.jpg' )), Expanded (child : Image . asset ( 'images/pic3.jpg' )), ], ); App source: sizing Packing widgets # By default, a row or column occupies as much space along its main axis as possible, but if you want to pack the children closely together, set its mainAxisSize to MainAxisSize.min . The following example uses this property to pack the star icons together. dart Row ( mainAxisSize : MainAxisSize .min, children :\n\n[ Icon ( Icons .star, color : Colors .green[ 500 ]), Icon ( Icons .star, color : Colors .green[ 500 ]), Icon ( Icons .star, color : Colors .green[ 500 ]), const Icon ( Icons .star, color : Colors .black), const Icon ( Icons .star, color : Colors .black), ],\n\n) App source: pavlova Nesting rows and columns # The layout framework allows you to nest rows and columns inside of rows and columns as deeply as you need. Let's look at the code for the outlined section of the following layout: The outlined section is implemented as two rows. The ratings row contains five stars and the number of reviews. The icons row contains three columns of icons and text. The widget tree for the ratings row: The ratings variable creates a row containing a smaller row of 5-star icons, and text: dart final stars = Row ( mainAxisSize : MainAxisSize .min, children : [ Icon ( Icons .star, color : Colors .green[ 500 ]), Icon ( Icons .star, color : Colors .green[ 500 ]),\n\nIcon ( Icons .star, color : Colors .green[ 500 ]), const Icon ( Icons .star, color : Colors .black), const Icon ( Icons .star, color : Colors .black), ], ); final ratings = Container ( padding : const EdgeInsets . all ( 20 ), child : Row (\n\nmainAxisAlignment : MainAxisAlignment .spaceEvenly, children : [ stars, const Text ( '170 Reviews' , style : TextStyle ( color : Colors .black, fontWeight : FontWeight .w800, fontFamily : 'Roboto' , letterSpacing : 0.5 , fontSize : 20 , ), ), ], ), ); The icons row, below the ratings row, contains 3 columns; each column contains an icon and two lines of text, as you can see in its widget tree: The\n\niconList variable defines the icons row: dart const descTextStyle = TextStyle ( color : Colors .black, fontWeight : FontWeight .w800, fontFamily : 'Roboto' , letterSpacing : 0.5 , fontSize : 18 , height : 2 , ); // DefaultTextStyle.merge() allows you to create a default text // style that is inherited by its child and all subsequent children. final iconList = DefaultTextStyle . merge ( style : descTextStyle,\n\nchild : Container ( padding : const EdgeInsets ."
  },
  {
    "chunk": "all ( 20 ), child : Row ( mainAxisAlignment : MainAxisAlignment .spaceEvenly, children : [ Column ( children : [ Icon ( Icons .kitchen, color : Colors .green[ 500 ]), const Text ( 'PREP:' ), const Text\n\n( '25 min' ), ], ), Column ( children : [ Icon ( Icons .timer, color : Colors .green[ 500 ]), const Text ( 'COOK:' ), const Text ( '1 hr' ), ], ), Column ( children : [ Icon ( Icons .restaurant, color : Colors .green[ 500 ]),\n\nconst Text ( 'FEEDS:' ), const Text ( '4-6' ), ], ), ], ), ), ); The leftColumn variable contains the ratings and icons rows, as well as the title and text that describes the Pavlova: dart final leftColumn = Container ( padding : const EdgeInsets . fromLTRB ( 20 , 30 , 20 , 20 ), child : Column (children\n\n: [titleText, subTitle, ratings, iconList]), ); The left column is placed in a SizedBox to constrain its width. Finally, the UI is constructed with the entire row (containing the left column and the image) inside a Card . The Pavlova image is from Pixabay . You can embed an image from the net using Image.network() but, for this example, the image is saved to an images directory in the project, added to the pubspec file , and accessed using Images.asset() . For more information, see Adding assets and images . dart body : Center ( child : Container ( margin : const EdgeInsets . fromLTRB ( 0 , 40 , 0 ,\n\n30 ), height : 600 , child : Card ( child : Row ( crossAxisAlignment : CrossAxisAlignment .start, children : [ SizedBox (width : 440 , child : leftColumn), mainImage, ], ), ), ), ), App source: pavlova Common layout widgets # Flutter has a rich library of layout widgets. Here are a few of those most commonly used. The intent is to get you up and running as quickly as possible, rather than overwhelm you with a complete list. For information on other available widgets, refer to the Widget catalog , or use the Search box in the API reference docs\n\n. Also, the widget pages in the API docs often make suggestions about similar widgets that might better suit your needs. The following widgets fall into two categories: standard widgets from the widgets library , and specialized widgets from the Material library . Any app can use the widgets library but only Material apps can use the Material Components library. Standard widgets Material widgets Cupertino widgets Container Adds padding, margins, borders, background color, or other decorations to a widget. GridView Lays widgets out as a scrollable grid. ListView Lays widgets out as a scrollable list. Stack Overlaps a widget on top of another. Scaffold Provides a structured layout framework with slots for common Material Design app elements. AppBar Creates a horizontal bar that's typically displayed at the top of a screen. Card Organizes related info into a box with rounded corners and a drop shadow. ListTile Organizes up to 3 lines of text, and optional leading and trailing icons, into a row. CupertinoPageScaffold Provides the basic layout structure for an iOS-style page."
  },
  {
    "chunk": "CupertinoNavigationBar Creates an iOS-style navigation bar at the top of the screen. CupertinoSegmentedControl Creates a segmented control for selecting. CupertinoTabBar and CupertinoTabScaffold Creates the characteristic iOS bottom tab bar. Container # Many layouts make liberal use of Container s to separate widgets using padding, or to add borders or margins. You can change the device's background by placing the entire layout into a Container\n\nand changing its background color or image. Summary (Container) # Add padding, margins, borders Change background color or image Contains a single child widget, but that child can be a Row , Column , or even the root of a widget tree Examples (Container) # This layout consists of a column with two rows, each containing 2 images. A Container is used to change the background color of the column to a lighter grey. dart Widget _buildImageColumn () { return Container ( decoration : const BoxDecoration (color : Colors .black26), child : Column (children : [ _buildImageRow ( 1 ), _buildImageRow ( 3 )]), );\n\n} A Container is also used to add a rounded border and margins to each image: dart Widget _buildDecoratedImage ( int imageIndex) => Expanded ( child : Container ( decoration : BoxDecoration ( border : Border . all (width : 10 , color : Colors .black38), borderRadius : const BorderRadius . all ( Radius . circular ( 8\n\n)), ), margin : const EdgeInsets . all ( 4 ), child : Image . asset ( 'images/pic $ imageIndex .jpg' ), ), ); Widget _buildImageRow ( int imageIndex) => Row ( children : [ _buildDecoratedImage (imageIndex), _buildDecoratedImage (imageIndex + 1 ), ], ); You can find more\n\nContainer examples in the tutorial . App source: container GridView # Use GridView to lay widgets out as a two-dimensional list. GridView provides two pre-fabricated lists, or you can build your own custom grid. When a GridView detects that its contents are too long to fit the render box, it automatically scrolls. Summary (GridView) # Lays widgets out in a grid Detects when the column content exceeds the render box and automatically provides scrolling Build your own custom grid, or use one of the provided grids: GridView.count allows you to specify the number of columns GridView.extent allows you to specify the maximum pixel width of a tile Examples (GridView) # Uses GridView.extent to create a grid with tiles a maximum 150 pixels wide. App source: grid_and_list Uses GridView.count to create a grid that's 2 tiles wide in portrait mode, and 3 tiles wide in landscape mode. The titles are created by setting the footer property for each GridTile . Dart code: grid_list_demo.dart dart Widget _buildGrid\n\n() => GridView . extent ( maxCrossAxisExtent : 150 , padding : const EdgeInsets . all ( 4 ), mainAxisSpacing : 4 , crossAxisSpacing : 4 , children : _buildGridTileList ( 30 ), ); // The images are saved with names pic0.jpg, pic1.jpg...pic29.jpg."
  },
  {
    "chunk": "// The List.generate() constructor allows an easy way to create // a list when objects have a predictable naming pattern. List < Widget > _buildGridTileList ( int count)\n\n=> List . generate (count, (i) => Image . asset ( 'images/pic $ i .jpg' )); ListView # ListView , a column-like widget, automatically provides scrolling when its content is too long for its render box. Summary (ListView) # A specialized Column for organizing a list of boxes Can be laid out horizontally or vertically Detects when its content won't fit and provides scrolling Less configurable than Column , but easier to use and supports scrolling Examples (ListView) # Uses ListView to display a list of businesses using ListTile s. A Divider separates the theaters from the restaurants. App source: grid_and_list Uses ListView to display the Colors\n\nfrom the Material 2 Design palette for a particular color family. Dart code: colors_demo.dart dart Widget _buildList () { return ListView ( children : [ _tile ( 'CineArts at the Empire' , '85 W Portal Ave' , Icons .theaters), _tile ( 'The Castro Theater' , '429 Castro St' , Icons .theaters), _tile ( 'Alamo Drafthouse Cinema' , '2550 Mission St' , Icons .theaters), _tile ( 'Roxie Theater' , '3117 16th St' ,\n\nIcons .theaters), _tile ( 'United Artists Stonestown Twin' , '501 Buckingham Way' , Icons .theaters, ), _tile ( 'AMC Metreon 16' , '135 4th St #3000' , Icons .theaters), const Divider (), _tile ( 'K \\' s Kitchen' , '757 Monterey Blvd' , Icons .restaurant), _tile ( 'Emmy \\' s Restaurant' , '1923 Ocean Ave' , Icons .restaurant), _tile ( 'Chaiya Thai Restaurant'\n\n, '272 Claremont Blvd' , Icons .restaurant), _tile ( 'La Ciccia' , '291 30th St' , Icons .restaurant), ], ); } ListTile _tile ( String title, String subtitle, IconData icon) { return ListTile ( title : Text ( title, style : const TextStyle (fontWeight : FontWeight .w500, fontSize : 20 ), ),\n\nsubtitle : Text (subtitle), leading : Icon (icon, color : Colors .blue[ 500 ]), ); } Stack # Use Stack to arrange widgets on top of a base widget‚Äîoften an image. The widgets can completely or partially overlap the base widget. Summary (Stack) # Use for widgets that overlap another widget The first widget in the list of children is the base widget; subsequent children are overlaid on top of that base widget A Stack 's content can't scroll You can choose to clip children that exceed the render box Examples (Stack) # Uses Stack to overlay a Container (that displays its Text on a translucent black background) on top of a CircleAvatar . The Stack offsets the text using the alignment property and\n\nAlignment s. App source: card_and_stack Uses Stack to overlay an icon on top of an image."
  },
  {
    "chunk": "Dart code: bottom_navigation_demo.dart dart Widget _buildStack () { return Stack ( alignment : const Alignment ( 0.6 , 0.6 ), children : [ const CircleAvatar ( backgroundImage : AssetImage ( 'images/pic.jpg' ), radius : 100 , ), Container ( decoration\n\n: const BoxDecoration (color : Colors .black45), child : const Text ( 'Mia B' , style : TextStyle ( fontSize : 20 , fontWeight : FontWeight .bold, color : Colors .white, ), ), ), ], ); } Card # A Card , from the Material library , contains related nuggets of information and can be composed of almost any widget, but is often used with ListTile\n\n. Card has a single child, but its child can be a column, row, list, grid, or other widget that supports multiple children. By default, a Card shrinks its size to 0 by 0 pixels. You can use SizedBox to constrain the size of a card. In Flutter, a Card features slightly rounded corners and a drop shadow, giving it a 3D effect. Changing a Card 's elevation property allows you to control the drop shadow effect. Setting the elevation to 24, for example, visually lifts the Card further from the surface and causes the shadow to become more dispersed. For a list of supported elevation values, see Elevation in the Material guidelines . Specifying an unsupported value disables the drop shadow entirely. Summary (Card) # Implements a Material card Used for presenting related nuggets of information Accepts a single child, but that child can be a Row , Column , or other widget that holds a list of children Displayed with rounded corners and a drop shadow A Card 's content can't scroll From the Material library Examples (Card) # A Card containing 3 ListTiles and sized by wrapping it with a SizedBox\n\n. A Divider separates the first and second ListTiles . App source: card_and_stack A Card containing an image and text. Dart code: cards_demo.dart dart Widget _buildCard () { return SizedBox ( height : 210 , child : Card ( child : Column ( children : [ ListTile ( title : const Text ( '1625 Main Street' , style :\n\nTextStyle (fontWeight : FontWeight .w500), ), subtitle : const Text ( 'My City, CA 99984' ), leading : Icon ( Icons .restaurant_menu, color : Colors .blue[ 500 ]), ), const Divider (), ListTile ( title : const Text ( '(408) 555-1212' , style : TextStyle (fontWeight : FontWeight .w500), ),\n\nleading : Icon ( Icons .contact_phone, color : Colors .blue[ 500 ]), ), ListTile ( title : const Text ( 'costa@example.com' ), leading : Icon ( Icons .contact_mail, color : Colors .blue[ 500 ]), ), ], ), ), ); } ListTile # Use ListTile , a specialized row widget from the Material library , for an easy way to create a row containing up to 3 lines of text and optional leading\n\nand trailing icons. ListTile is most commonly used in Card or ListView , but can be used elsewhere."
  },
  {
    "chunk": "Summary (ListTile) # A specialized row that contains up to 3 lines of text and optional icons Less configurable than Row , but easier to use From the Material library Examples (ListTile) # A Card containing 3 ListTile s. App source: card_and_stack Uses ListTile with leading widgets. Dart code: list_demo.dart Constraints # To fully understand Flutter's layout system, you need to learn how Flutter positions and sizes the components in a layout. For more information, see Understanding constraints . Videos # The following videos, part of the Flutter in Focus series, explain Stateless and Stateful widgets. Watch on YouTube in a new tab: \"How to create stateless widgets\"\n\nWatch on YouTube in a new tab: \"How and when stateful widgets are best used\" Flutter in Focus playlist Each episode of the Widget of the Week series focuses on a widget. Several of them include layout widgets. Watch on YouTube in a new tab: \"Introducing widget of the week\" Flutter Widget of the Week playlist Other resources # The following resources might help when writing layout code. Layout tutorial Learn how to build a layout. Widget catalog Describes many of the widgets available in Flutter. HTML/CSS Analogs in Flutter For those familiar with web programming, this page maps HTML/CSS functionality to Flutter features. API reference docs Reference documentation for all of the Flutter libraries. Adding assets and images Explains how to add images and other assets to your app's package. Zero to One with Flutter One person's experience writing their first Flutter app. Was this page's content helpful? thumb_up thumb_down Thank you for your feedback! feedback Provide details Thank you for your feedback! Please let us know what we can do to improve. bug_report Provide details Unless stated otherwise, the documentation on this site reflects the latest stable version of Flutter. Page last updated on 2025-05-19. View source or report an issue .\n\nConte√∫do de: https://docs.flutter.dev/ui/layout/tutorial Layout tutorial | Flutter docs.flutter.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic. Learn more . OK, got it list On this page chevron_right Build a Flutter layout vertical_align_top Build a Flutter layout Flutter is back at Google I/O! Watch live keynotes & sessions This tutorial explains how to design and build layouts in Flutter. If you use the example code provided, you can build the following app. The finished app. Photo by Dino Reichmuth on Unsplash . Text by Switzerland Tourism . To get a better overview of the layout mechanism, start with Flutter's approach to layout . Diagram the layout # In this section, consider what type of user experience you want for your app users. Consider how to position the components of your user interface. A layout consists of the total end result of these positionings. Consider planning your layout to speed up your coding. Using visual cues to know where something goes on screen can be a great help."
  },
  {
    "chunk": "Use whichever method you prefer, like an interface design tool or a pencil and a sheet of paper. Figure out where you want to place elements on your screen before writing code. It's the programming version of the adage: \"Measure twice, cut once.\" Ask these questions to break the layout down to its basic elements. Can you identify the rows and columns? Does the layout include a grid? Are there overlapping elements? Does the UI need tabs? What do you need to align, pad, or border? Identify the larger elements. In this example, you arrange the image, title, buttons, and\n\ndescription into a column. Major elements in the layout: image, row, row, and text block Diagram each row. Row 1, the Title section, has three children: a column of text, a star icon, and a number. Its first child, the column, contains two lines of text. That first column might need more space. Title section with text blocks and an icon Row 2, the Button section, has three children: each child contains a column which then contains an icon and text. The Button section with three labeled buttons After diagramming the layout, consider how you would code it. Would you write all the code in one class? Or, would you create one class for each part of the layout? To follow Flutter best practices, create one class, or Widget, to contain each part of your layout. When Flutter needs to re-render part of a UI, it updates the smallest part that changes. This is why Flutter makes \"everything a widget\". If only the text changes in a Text widget, Flutter redraws only that text. Flutter changes the least amount of the UI possible in response to user input. For this tutorial, write each element you have identified as its own widget. Create the app base code # In this section, shell out the basic Flutter app code to start your app. Set up your Flutter environment . Create a new Flutter app . Replace the contents of lib/main.dart with the following code. This app uses a parameter for the app title and the title shown on the app's appBar . This decision simplifies the code. dart import 'package:flutter/material.dart' ; void main () =>\n\nrunApp ( const MyApp ()); class MyApp extends StatelessWidget { const MyApp ({ super .key}); @override Widget build ( BuildContext context) { const String appTitle = 'Flutter layout demo' ; return MaterialApp ( title : appTitle, home : Scaffold ( appBar : AppBar (title : const Text (appTitle)),\n\nbody : const Center ( child : Text ( 'Hello World' ), ), ), ); } } Add the Title section # In this section, create a TitleSection widget that resembles the following layout. The Title section as sketch and prototype UI Add the TitleSection Widget # Add the following code after the MyApp class. dart class TitleSection extends StatelessWidget { const TitleSection ({ super .key, required this .name, required this\n\n.location}); final String name; final String location; @override Widget build ( BuildContext context) { return Padding ( padding : const EdgeInsets ."
  },
  {
    "chunk": "all ( 32 ), child : Row ( children : [ Expanded ( /*1*/ child : Column ( crossAxisAlignment : CrossAxisAlignment .start, children :\n\n[ /*2*/ Padding ( padding : const EdgeInsets . only (bottom : 8 ), child : Text ( name, style : const TextStyle (fontWeight : FontWeight .bold), ), ), Text (location, style : TextStyle (color : Colors .grey[ 500 ])), ], ), ), /*3*/ Icon (\n\nIcons .star, color : Colors .red[ 500 ]), const Text ( '41' ), ], ), ); } } To use all remaining free space in the row, use the Expanded widget to stretch the Column widget. To place the column at the start of the row, set the crossAxisAlignment property to CrossAxisAlignment.start . To add space between the rows of text, put those rows in a Padding widget. The title row ends with a red star icon and the text 41 . The entire row falls inside a Padding widget and pads each edge by 32 pixels. Change the app body to a scrolling view # In the body property, replace the Center widget with a SingleChildScrollView widget. Within the SingleChildScrollView widget, replace the\n\nText widget with a Column widget. dart body : const Center ( child : Text ( 'Hello World' ), body : const SingleChildScrollView ( child : Column ( children : [ These code updates change the app in the following ways. A SingleChildScrollView widget can scroll. This allows elements that don't fit on the current screen to display. A Column widget displays any elements within its children property in the order listed. The first element listed in the children list displays at the top of the list. Elements in the children list display in array order on the screen from top to bottom. Update the app to display the title section # Add the TitleSection\n\nwidget as the first element in the children list. This places it at the top of the screen. Pass the provided name and location to the TitleSection constructor. dart children : [ TitleSection ( name : 'Oeschinen Lake Campground' , location : 'Kandersteg, Switzerland' , ), ], Add the Button section # In this section, add the buttons that will add functionality to your app. The Button section contains three columns that use the same layout: an icon over a row of text. The Button section as sketch and prototype UI Plan to distribute these columns in one row so each takes the same amount of space. Paint all text and icons with the primary color. Add the ButtonSection widget # Add the following code after the TitleSection widget to contain the code to build the row of buttons. dart class ButtonSection extends StatelessWidget { const ButtonSection\n\n({ super .key}); @override Widget build ( BuildContext context) { final Color color = Theme . of (context).primaryColor; // ¬∑¬∑¬∑ } } Create a widget to make buttons # As the code for each column could use the same syntax, create a widget named ButtonWithText . The widget's constructor accepts a color, icon data, and a label for the button. Using these values, the widget builds a Column with an Icon and a stylized Text widget as its children."
  },
  {
    "chunk": "To help separate these children, a Padding widget the Text widget is wrapped with a Padding widget. Add the following code after the ButtonSection class. dart class ButtonSection extends\n\nStatelessWidget { const ButtonSection ({ super .key}); // ¬∑¬∑¬∑ } class ButtonWithText extends StatelessWidget { const ButtonWithText ({ super .key, required this .color, required this .icon, required this .label, }); final Color color; final IconData icon; final String label; @override Widget build ( BuildContext context) { return\n\nColumn ( mainAxisSize : MainAxisSize .min, mainAxisAlignment : MainAxisAlignment .center, children : [ Icon (icon, color : color), Padding ( padding : const EdgeInsets . only (top : 8 ), child : Text ( label, style : TextStyle ( fontSize : 12 , fontWeight : FontWeight\n\n.w400, color : color, ), ), ), ], ); } Position the buttons with a Row widget # Add the following code into the ButtonSection widget. Add three instances of the ButtonWithText widget, once for each button. Pass the color, Icon , and text for that specific button. Align the columns along the main axis with the MainAxisAlignment.spaceEvenly value. The main axis for a Row widget is horizontal and the main axis for a Column widget is vertical. This value, then, tells Flutter to arrange the free space in equal amounts before, between, and after each column along the Row . dart class ButtonSection extends StatelessWidget { const ButtonSection ({ super .key}); @override\n\nWidget build ( BuildContext context) { final Color color = Theme . of (context).primaryColor; return SizedBox ( child : Row ( mainAxisAlignment : MainAxisAlignment .spaceEvenly, children : [ ButtonWithText (color : color, icon : Icons .call, label : 'CALL' ), ButtonWithText (color : color, icon : Icons .near_me, label :\n\n'ROUTE' ), ButtonWithText (color : color, icon : Icons .share, label : 'SHARE' ), ], ), ); } } class ButtonWithText extends StatelessWidget { const ButtonWithText ({ super .key, required this .color, required this .icon, required this .label, }); final Color color; final IconData icon; final String\n\nlabel; @override Widget build ( BuildContext context) { return Column ( // ¬∑¬∑¬∑ ); } } Update the app to display the button section # Add the button section to the children list. dart TitleSection ( name : 'Oeschinen Lake Campground' , location : 'Kandersteg, Switzerland' , ), ButtonSection (), ], Add the Text section # In this section, add the text description to this app. The text block as sketch and prototype UI Add the TextSection widget # Add the following code as a separate widget after the ButtonSection widget.\n\ndart class TextSection extends StatelessWidget { const TextSection ({ super .key, required this .description}); final String description; @override Widget build ( BuildContext context) { return Padding ( padding : const EdgeInsets ."
  },
  {
    "chunk": "all ( 32 ), child : Text (description, softWrap : true ), ); } }\n\nBy setting softWrap to true , text lines fill the column width before wrapping at a word boundary. Update the app to display the text section # Add a new TextSection widget as a child after the ButtonSection . When adding the TextSection widget, set its description property to the text of the location description. dart location : 'Kandersteg, Switzerland' , ), ButtonSection (), TextSection ( description : 'Lake Oeschinen lies at the foot of the Bl√ºemlisalp in the ' 'Bernese Alps. Situated 1,578 meters above sea level, it ' 'is one of the larger Alpine Lakes. A gondola ride from ' 'Kandersteg, followed by a half-hour walk through pastures ' 'and pine forest, leads you to the lake, which warms to 20 ' 'degrees Celsius in the summer. Activities enjoyed here ' 'include rowing, and riding the summer toboggan run.' , ), ], Add the Image section # In this section, add the image file to complete your layout. Configure your app to use supplied images # To configure your app to reference images, modify its pubspec.yaml\n\nfile. Create an images directory at the top of the project. Download the lake.jpg image and add it to the new images directory. To include images, add an assets tag to the pubspec.yaml file at the root directory of your app. When you add assets , it serves as the set of pointers to the images available to your code. pubspec.yaml yaml flutter : uses-material-design : true assets : images/lake.jpg Create the ImageSection widget # Define the following ImageSection widget after the other declarations. dart class ImageSection extends StatelessWidget { const ImageSection ({ super .key,\n\nrequired this .image}); final String image; @override Widget build ( BuildContext context) { return Image . asset (image, width : 600 , height : 240 , fit : BoxFit .cover); } } The BoxFit.cover value tells Flutter to display the image with two constraints. First, display the image as small as possible. Second, cover all the space that the layout allotted, called the render box. Update the app to display the image section # Add an ImageSection widget as the first child in the children list. Set the image property to the path of the image you added in Configure your app to use supplied images . dart\n\nchildren : [ ImageSection ( image : 'images/lake.jpg' , ), TitleSection ( name : 'Oeschinen Lake Campground' , location : 'Kandersteg, Switzerland' , Congratulations # That's it! When you hot reload the app, your app should look like this. The finished app Resources # You can access the resources used in this tutorial from these locations: Dart code: main.dart Image: ch-photo Pubspec: pubspec.yaml Next Steps # To add interactivity to this layout, follow the interactivity tutorial . Was this page's content helpful? thumb_up thumb_down Thank you for your feedback! feedback Provide details Thank you for your feedback!"
  },
  {
    "chunk": "Please let us know what we can do to improve.\n\nbug_report Provide details Unless stated otherwise, the documentation on this site reflects the latest stable version of Flutter. Page last updated on 2025-03-10. View source or report an issue .\n\nConte√∫do de: https://docs.flutter.dev/cookbook/lists/basic-list Use lists | Flutter docs.flutter.dev uses cookies from Google to deliver and enhance the quality of its services and to analyze traffic. Learn more . OK, got it list On this page chevron_right Use lists vertical_align_top Use lists Flutter is back at Google I/O! Watch live keynotes & sessions Displaying lists of data is a fundamental pattern for mobile apps. Flutter includes the ListView widget to make working with lists a breeze. Create a ListView # Using the standard ListView constructor is perfect for lists that contain only a few items. The built-in ListTile widget is a way to give items a visual structure. dart ListView ( children : const < Widget > [ ListTile (leading : Icon ( Icons .map), title : Text\n\n( 'Map' )), ListTile (leading : Icon ( Icons .photo_album), title : Text ( 'Album' )), ListTile (leading : Icon ( Icons .phone), title : Text ( 'Phone' )), ], ), Interactive example # import 'package:flutter/material.dart'; void main() => runApp(const MyApp()); class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { const title = 'Basic List'; return MaterialApp( title: title, home: Scaffold( appBar: AppBar(title: const Text(title)), body: ListView( children: const <Widget>[ ListTile(leading: Icon(Icons.map), title: Text('Map')),\n\nListTile(leading: Icon(Icons.photo_album), title: Text('Album')), ListTile(leading: Icon(Icons.phone), title: Text('Phone')), ], ), ), ); } } Was this page's content helpful? thumb_up thumb_down Thank you for your feedback! feedback Provide details Thank you for your feedback! Please let us know what we can do to improve. bug_report Provide details Unless stated otherwise, the documentation on this site reflects the latest stable version of Flutter. Page last updated on 2025-02-12. View source or report an issue ."
  }
]